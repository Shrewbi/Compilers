\documentclass[12pt]{article}
\usepackage[utf8]{inputenc} % æøå
\usepackage[T1]{fontenc} % mere æøå
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage{mdwlist}
\usepackage{graphicx}

\title{Oversættere Group Assignment}
\author{Martin Thiele, Alexander Mathiesen, Daniel Eyþórsson}
\date{\parbox{\linewidth}{\centering%
  20. december 2015\endgraf\bigskip
  Studienummer: mqn507, pkq530, kzs773\endgraf\medskip
  Email: <Studienummer> @alumni.ku.dk\endgraf}}

\begin{document}
\maketitle

\section{Introduction}
We have decided to divide this report into three parts, one for each task. Each of this parts will then cover the different implementations we have made, the changes we have made to the different files, as well as any problems we may have encountered.
\section{Warm up implementations}
For the first task of the assignment we were asked to implement multiplication, division, boolean operators and literals. We have modified the following files: Lexer.lex, Parser.grm, Interpreter.sml, TypeChecker.sml and CodeGen.sml.
\subsection{Boolean literals}
\subsubsection{Lexer.lex}

We added "true" and "false" by adding the tokens known as TRUE and FALSE. These both take a position as their only argument.
\begin{verbatim}
    | "true"    => Parser.TRUE pos
    | "false"   => Parser.FALSE pos
\end{verbatim}
\subsubsection{Parser.grm}
We added a token "BOOLVAL" to the list and defined it to take two arguments; a boolean value and a position, which is a tuple of integers:
\begin{verbatim}
%token <(int*int)> TRUE FALSE
\end{verbatim}

We now need to add these to their expression cases. Since they are booleans and constants, they don't take any expressions, and results to the following:
\begin{verbatim}
        | TRUE             { Constant(BoolVal(true), $1)  }
        | FALSE            { Constant(BoolVal(false), $1) }
\end{verbatim}

\subsubsection{Interpreter.sml}
No modifications were needed in this file. 
\subsubsection{TypeChecker.sml}
No modifications were needed in this file.
\subsubsection{CodeGen.sml}
We implemented booleans in the "Constant" case of the "compileExp" function. It takes a boolean expression \(b\) and a position as parameters. If \(b\) evaluates to true, then it loads the value 1, and 0 otherwise. It uses the MIPS instruction "load immediate": 
\begin{verbatim}
  | Constant (BoolVal b, pos) =>
    if b then [ Mips.LI (place, makeConst 1) ]
    else [ Mips.LI (place, makeConst 0) ]
\end{verbatim}
\subsection{Multiplication and division}
\subsubsection{Lexer.lex}
We added "*" and "/" cases to the keyword function. We assume the implementation in the parser phase takes a single argument; its position which is a tuple of integers:
\begin{verbatim}
       | "*"            => Parser.MULT pos
       | "/"            => Parser.DIV pos
\end{verbatim}
\subsubsection{Parser.grm}
We modified the token that handles the binary operators such as plus and minus etc. to also handle multiplication and division: 
\begin{verbatim}
%token <(int*int)> PLUS MINUS DEQ EQ LTH MULT DIV 
\end{verbatim}
\subsubsection{Interpreter.sml}
We added cases to the "evalExp" function to handle multiplication ("Times") and division ("Divide"). They take as parameters two expressions, a position and two symbol tables. They then evaluate the two expressions and make sure that both are integer types before carrying out the respective operation: 
\begin{verbatim}
  | evalExp ( Times(e1, e2, pos), vtab, ftab ) =
        let val res1   = evalExp(e1, vtab, ftab)
            val res2   = evalExp(e2, vtab, ftab)
        in  case (res1, res2) of
              (IntVal n1, IntVal n2) => IntVal (n1*n2)
            | _ => invalidOperands "Multiplication on non-integral args: " 
            [(Int, Int)] res1 res2 pos
        end

  | evalExp ( Divide(e1, e2, pos), vtab, ftab ) = 
        let val res1   = evalExp(e1, vtab, ftab)
            val res2   = evalExp(e2, vtab, ftab)
        in  case (res1, res2) of
              (IntVal n1, IntVal n2) => IntVal (n1 div n2)
            | _ => invalidOperands "Division on non-integral args: " 
            [(Int, Int)] res1 res2 pos
        end
\end{verbatim}
\subsubsection{TypeChecker.sml}
We added cases to the "checkExp" function to handle multiplication ("Times") and division ("Divide"). They take as parameters two expressions and a position. Then the "checkBinOp" function is invoked to make sure both expressions are of the same, correct type:
\begin{verbatim}
    | In.Times (e1, e2, pos)
      => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
         in (Int,
             Out.Times (e1_dec, e2_dec, pos))
         end
    | In.Divide (e1, e2, pos)
      => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
         in (Int,
             Out.Divide (e1_dec, e2_dec, pos))
         end
\end{verbatim}
\subsubsection{CodeGen.sml}
We implemented multiplication and division by adding them as cases to the "compileExp" function. It then evaluates each expression and invokes the Mips instructions "MUL" and "DIV" respectively. 
\begin{verbatim}
  | Times (e1, e2, pos) =>
      let val t1 = newName "minus_L"
          val t2 = newName "minus_R"
          val code1 = compileExp e1 vtable t1
          val code2 = compileExp e2 vtable t2
      in  code1 @ code2 @ [Mips.MUL (place,t1,t2)]
      end
  | Divide (e1, e2, pos) =>
      let val t1 = newName "minus_L"
          val t2 = newName "minus_R"
          val code1 = compileExp e1 vtable t1
          val code2 = compileExp e2 vtable t2
      in  code1 @ code2 @ [Mips.DIV (place,t1,t2)]
      end
\end{verbatim}
\subsubsection{Tests}


\subsection{AND and OR}
\subsubsection{Lexer.lex}
We added "and" as well as "or" as symbols instead of text as "and" as well as "or" usually is being used with a different meaning when writing SML.
\begin{verbatim}
  | "&&"                { Parser.AND    (getPos lexbuf) }
  | "||"                { Parser.OR     (getPos lexbuf) }
\end{verbatim}
\subsubsection{Parser.grm}
We modified the token that handles if-then-else statements to also handle AND as well as OR
\begin{verbatim}
%token <(int*int)> AND OR
\end{verbatim}
We followed the plus and minus case and determined that we needed to implement associatives for the tokens.
thus:
\begin{verbatim}
%left  OR AND
\end{verbatim}
In order for the two expressions to work, they need to be implemented as expressions later on in the parser. We have done this by doing the following:
\begin{verbatim}
        | Exp AND     Exp  { And    ($1, $3, $2) }
        | Exp OR      Exp  { Or     ($1, $3, $2) }
\end{verbatim}

\subsubsection{Interpreter.sml}
We added cases to the "evalExp" function to handle AND (And) as well as OR (Or). They take as parameters two expressions, a position and two symbol tables. They then evaluate the two expressions and make sure that we are dealing with BoolVals, before carrying out the operation:

\begin{verbatim}
  | evalExp (And (e1, e2, pos), vtab, ftab) =
        let val res1   = evalExp(e1, vtab, ftab)
            val res2   = evalExp(e2, vtab, ftab)
        in  case (res1, res2) of
              (BoolVal n1, BoolVal n2) => if n1 then BoolVal (n1 = n2) 
                                                else BoolVal false
            | _ => invalidOperands "And on non-integral args: "
                   [(Bool, Bool)] res1 res2 pos
        end
\end{verbatim}
\clearpage
\begin{verbatim}
  | evalExp (Or (e1, e2, pos), vtab, ftab) =
        let val res1   = evalExp(e1, vtab, ftab)
            val res2   = evalExp(e2, vtab, ftab)
        in  case (res1, res2) of
              (BoolVal n1, BoolVal n2) => if not n1 then BoolVal (n1 <> n2) 
                                                    else BoolVal true
            | _ => invalidOperands "Or on non-integral args: " 
                   [(Bool, Bool)] res1 res2 pos
        end
\end{verbatim}

\subsubsection{TypeChecker.sml}
In the typechecker we check if e1 is a boolean, this is done to short-circuit. If e1 is a boolean, then e2 is checked in the case of being another boolean. If it is then we continue on, else we raise an error


\begin{verbatim}
    | In.And (e1, e2, pos)
      => let val (t1, e1_dec) = checkExp ftab vtab e1
          in if t1 = Bool
            then let val (t2, e2_dec) = checkExp ftab vtab e2
             in if t2 = Bool then (Bool, Out.And(e1_dec, e2_dec, pos))
                else raise Error (("Wrong type: " ^ ppType t2), pos) end
            else raise Error (("Wrong type: " ^ ppType t1), pos)
          end

    | In.Or (e1, e2, pos)
      => let val (t1, e1_dec) = checkExp ftab vtab e1
          in if t1 = Bool
            then let val (t2, e2_dec) = checkExp ftab vtab e2
              in if t2 = Bool then (Bool, Out.Or(e1_dec, e2_dec, pos))
              else raise Error (("Wrong type: " ^ ppType t2), pos) end
          else raise Error (("Wrong type: " ^ ppType t1), pos)
          end
\end{verbatim}
\subsubsection{CodeGen.sml}
We implemented AND as well as OR evaluations by adding them to the "compileExp" function. For the "AND" case, we first create a "falseLabel" which marks a false evaluation. We then load the value 0 as we assume the expression returns false. We then use the "BEQ" instruction in Mips to see if \(t1 = 0\) (using the \(\$0\) register in Mips), in which case we know to the "AND" expression can only return false, and we jump to the "falseLabel". This is to maintain a short circuit structure. We then use the "BNE" instruction to see if \(t1\neq t2\). Since we know at this point that \(t1\) is true, if this returns true, then \(t2\) must be false, and we jump to the "falseLabel". 
\begin{verbatim}
  | And (e1, e2, pos) =>
      let val t1 = newName "and_L"
          val t2 = newName "and_R"
          val code1 = compileExp e1 vtable t1
          val code2 = compileExp e2 vtable t2
          val falseLabel = newName "false"
      in  code1 @ code2 @
          [ Mips.LI (place, "0")
          , Mips.BEQ (t1,"$0",falseLabel)
          , Mips.BNE (t1,t2,falseLabel)
          , Mips.LI (place,"1") 
          , Mips.LABEL falseLabel ]
      end
      
  | Or (e1, e2, pos) =>
      let val t1 = newName "or_L"
          val t2 = newName "or_R"
          val code1 = compileExp e1 vtable t1
          val code2 = compileExp e2 vtable t2
          val trueLabel = newName "true"
      in  code1 @ code2 @
          [ Mips.LI (place, "1")
          , Mips.BNE (t1,"$0",trueLabel)
          , Mips.BNE (t1,t2,trueLabel)
          , Mips.LI (place,"0")
          , Mips.LABEL trueLabel ]
      end

\end{verbatim}
\subsubsection{Tests}
\subsection{Not and negation}
\subsubsection{Lexer.lex}
We added not and negate to our lexer file by using the symbols "!" and "$\sim$" respectively. There was no mention of this in the assignment, so we felt this would be most logical, seeing how these are already the recognized as their respective symbols in a lot of programming languages.
\subsubsection{Parser.grm}
We modified the token that handles if-then-else statements to also handle NOT as well as NEGATE
\begin{verbatim}
%token <(int*int)> NOT NEGATE
\end{verbatim}

By using the same logic for plus and minus we had to add a precedence to our NOT and NEGATE cases. These are done as so
\begin{verbatim}
%nonassoc NEGATE NOT
\end{verbatim}
And just as well, we need to add them in their expression cases as well. These only take one expression which differs from the previous ones
\begin{verbatim}
        | NOT         Exp  { Not    ($2, $1)     }
        | NEGATE      Exp  { Negate ($2, $1)     }
\end{verbatim}


\subsubsection{Interpreter.sml}
We added cases to the "evalExp" function to handle NOT (Not) as well as NEGATE (Negate). They take as parameters an expression, a position and two symbol tables. They then evaluate the expression and make sure that we are dealing with a BoolVal in \textbf{Not}, and an IntVal in \textbf{Negate}, before carrying out the operation:

\begin{verbatim}
  | evalExp ( Not(e, pos), vtab, ftab ) =
        let val res = evalExp(e, vtab, ftab)
        in case res of BoolVal n => BoolVal(if n = true then false else true)
            | _ => invalidOperands "Not on non-boolean arg: " [(Bool, Bool)] res res pos
Dr        end
\end{verbatim}
\begin{verbatim}
  | evalExp ( Negate(e, pos), vtab, ftab ) =
        let val res = evalExp(e, vtab, ftab)
        in case res of IntVal n => IntVal(0-n)
            | _ => invalidOperands "Negate on non-integral arg: " [(Int, Int)] res res pos
        end
\end{verbatim}
\subsubsection{TypeChecker.sml}
For the first case, not, we check if the expression is a boolean, if it is carry on, else raise error. In the second case of negate, we check if the expression is an integer, if it is we carry on.
\begin{verbatim}
    | In.Not (e, pos)
      => let val (t, e_dec) = checkExp ftab vtab e
          in if t = Bool then (Bool, Out.Not(e_dec, pos))
          else raise Error (("Wrong type: " ^ ppType t), pos) 
          end

    | In.Negate (e, pos)
      => let val (t, e_dec) = checkExp ftab vtab e
          in if t = Int then (Int, Out.Negate(e_dec, pos))
          else raise Error (("Wrong type: " ^ ppType t), pos) 
          end
\end{verbatim}
\subsubsection{CodeGen.sml}
We implemented NOT as well as NEGATE evaluations by adding them to the "compileExp" function. It then evaluates each expression and invokes the following mips instructions:

\textbf{NOT}
\begin{verbatim}
          [Mips.XORI (place,t, "1")]
\end{verbatim}

\textbf{OR}
\begin{verbatim}
          [Mips.SUB (place, "$0", t)]
\end{verbatim}
\clearpage
\textbf{Full code:}
\begin{verbatim}
  | Not (e', pos) =>
      let val t = newName "not_arg"
          val code = compileExp e' vtable t
      in code @ [Mips.XORI (place,t, "1")]
      end
  | Negate (e', pos) =>
      let val t = newName "not_arg"
          val code = compileExp e' vtable t
      in code @ [Mips.SUB (place, "$0", t)]
      end
\end{verbatim}
\subsubsection{Tests}
\subsection{MAP and REDUCE}
\subsubsection{Lexer.lex}
In the lexer we added the required tokens for both map and reduce to work
\begin{verbatim}
       | "map"          => Parser.MAP pos
       | "reduce"       => Parser.REDUCE pos
\end{verbatim}
\subsubsection{Parser.grm}
In the parser, we initialize by reading the tokens from the lexer, it takes a position and is done by doing the following:
\begin{verbatim}
%token <(int*int)> MAP REDUCE
\end{verbatim}

Then, the expression cases are written with the correct registers and paranthesis as well as commas. This is done like so:
\begin{verbatim}
        | MAP LPAR FunArg COMMA Exp RPAR
                        { Map ($3, $5, (), (),  $1) }

        | REDUCE LPAR FunArg COMMA Exp COMMA Exp RPAR
                        { Reduce ($3, $5, $7, (), $1)}
\end{verbatim}

\subsubsection{Interpreter.sml}
Next, we implement map and reduce in our interpreter

\begin{verbatim}
  | evalExp ( Map (farg, arrexp, _, _, pos), vtab, ftab ) =
        let val arr  = evalExp(arrexp, vtab, ftab)
            val farg_ret_type = rtpFunArg (farg, ftab, pos)
        in case arr of
               ArrayVal (lst,tp1) =>
               let val mlst = map (fn x => evalFunArg (farg, vtab, ftab, pos, [x])) lst
               in  ArrayVal (mlst, farg_ret_type)
               end
             | _ => raise Error("Map: Wrong argument: " ^ppVal 0 arr, pos)
        end

  | evalExp ( Reduce (farg, ne, arrexp, tp, pos), vtab, ftab ) =
            let val arr  = evalExp(arrexp, vtab, ftab)
                val e  = evalExp(ne, vtab, ftab)
                val farg_ret_type = rtpFunArg (farg, ftab, pos)
        in case arr of
               ArrayVal (lst,tp1) =>
               foldl (fn (x,y) => evalFunArg (farg, vtab, ftab, pos, [x,y])) e lst
             | _ => raise Error("Reduce: Wrong argument: " ^ppVal 0 arr, pos)
        end
\end{verbatim}
\subsubsection{TypeChecker.sml}
For our typechecker, we first need to check that our array expression truly is an array, if not we raise an error. Then we check the function argument, and if wrong type, raise error, lastly we check if our element type is the same as the function argument (and n_exp has the same type as the f_arg in the reduce case). If they are we can continue to the codegen.
\begin{verbatim}
    | In.Map (f, arr_exp, _, _, pos)
      => let val (a_type, arr_exp_dec) = checkExp ftab vtab arr_exp
             val e_type = 
              case a_type of Array r => r
                          |  _ => raise Error("Map: wrong argument type " ^ ppType a_type, pos)
             val (f', f_ret, f_arg) = 
              case checkFunArg (f, vtab, ftab, pos) of
                (f', ret, [t]) => (f', ret, t)
               | (_,  ret, args) => raise Error("Map: wrong argument type " ^ ppType e_type, pos)
          in if e_type = f_arg 
             then (Array f_ret, Out.Map (f', arr_exp_dec, e_type, f_ret, pos))
             else raise Error ("Map: incompatible arguments " ^ ppType e_type, pos)
          end
          
    | In.Reduce (f, n_exp, arr_exp, _, pos)
      => let val (a_type, arr_exp_dec) = checkExp ftab vtab arr_exp
             val e_type = 
              case a_type of Array r => r
                          |  _ => raise Error("Reduce: wrong argument type " ^ ppType a_type, pos)
             val (n_type, n_exp_dec) = checkExp ftab vtab n_exp
             val (f', f_ret, f_arg) = 
              case checkFunArg (f, vtab, ftab, pos) of
                (f', ret, [t]) => (f', ret, t)
               | (_,  ret, args) => raise Error("Reduce: wrong argument type " ^ ppType e_type, pos)
          in if (e_type = f_arg andalso n_type = f_arg)
             then (e_type, Out.Reduce (f', n_exp_dec, arr_exp_dec, e_type, pos))
             else raise Error ("Reduce: incompatible arguments " ^ ppType e_type, pos)
          end
\end{verbatim}

\clearpage
\subsubsection{CodeGen.sml}
z
\subsubsection{Tests}
\subsection{Binary operators}
Unfortunately we did not get around to this, and all we managed to do was implement the unknown BinOp in the parser.
\section{Task 3}


\end{document}